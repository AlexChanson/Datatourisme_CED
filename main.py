# -*- coding: utf-8 -*-
"""Similarity for multi-symbol.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1F_WVaXVBpo2fc5nGmlpOC70z9oVVVJm8

# Init
"""

from functools import lru_cache

import matplotlib.pyplot as plt
import networkx as nx
import pandas as pd
from numpy.random import choice
from pyvis.network import Network
from scipy.cluster.hierarchy import dendrogram, linkage

from CED import *
from Context_function import gaussian
from graphs import datatourisme_hist, datatourisme_theme, chain, all_successors, all_predecessors


# Load data
ID_PREFIX = "https://data.datatourisme.gouv.fr/"  # Ids (URI) have been striped for memory/ease of use
INSTANCES_FILE = "data/output.csv"
ONTOLOGY_FILE = "data/graph"


# Main utility fonctions
def degeneralize(concepts, ontology):
    more_general = set()

    for concept in concepts:
        to_rem = all_predecessors(ontology, concept)
        to_rem.remove(concept)

        more_general.update(to_rem)

    return concepts.difference(more_general)


def display(G, filename, size_dynamic=True, height='750px', width="100%", notebook=True):
    # pyvis.Network
    g = Network(height=height, width=width, directed=True, heading=filename.rstrip(".html"))

    if size_dynamic:
        size = lambda Graph, node: 80 * len(all_successors(Graph, node, []))
    else:
        size = lambda Graph, node: 80

    for n in G:
        if n == "Start":
            g.add_node(n, value=size(G, n), label=n, color="Green")
        elif n == "Sleep":
            g.add_node(n, value=size(G, n), label=n, color="Red")
        else:
            g.add_node(n, value=size(G, n), label=n, )
    for edge in G.edges:
        try:
            g.add_edge(edge[0], edge[1], label=G.get_edge_data(edge[0], edge[1])["weight"])
        except KeyError:
            g.add_edge(edge[0], edge[1])

    g.show_buttons(filter_=['physics'])
    g.show(filename)


"""# Halkidi"""


@lru_cache(maxsize=100000)
def wu_palmer(x, y, Ontologie, rootnode="All"):
    return (2.0 * nx.shortest_path_length(Ontologie, rootnode, nx.lowest_common_ancestor(Ontologie, x, y))) / (
                nx.shortest_path_length(Ontologie, rootnode, x) + nx.shortest_path_length(Ontologie, rootnode, y))


# New stuff
def halkidi(X, Y, delta, ontology):
    if len(X) == 0 or len(Y) == 0:
        return 0
    return 1.0 / 2 * (
            1.0 / len(X) * sum(max(delta(x, y, ontology) for y in Y) for x in X) +
            1.0 / len(Y) * sum(max(delta(x, y, ontology) for x in X) for y in Y)
    )


def mval_sim(s, s_, onts):
    sum_ = 0
    for i, ont in enumerate(onts):
        sum_ += halkidi(s[i], s_[i], wu_palmer, ont)

    return sum_ / float(len(onts))


"""## Model Vis"""

# Display code - Markov model
# display(chain, "markov.html", size_dynamic=False, height="600px", width="70%")

"""## Sequence Gen"""


def build_basic_sequence(markov, start_node, end_node, append_end_node=True):
    def white_walker(acc):
        successors = markov.successors(acc[-1])
        probas = []
        items = []
        for next in successors:
            items.append(next)
            probas.append(markov.get_edge_data(acc[-1], next)["weight"])
        # numpy.random.choice
        draw = choice(items, 1, p=probas)[0]

        if draw == end_node:
            if append_end_node:
                acc.append(draw)
            return acc

        acc.append(draw)
        return white_walker(acc)

    return white_walker([start_node])


def build_instance_sequence(base_seq, instance_map, start_node_swap="Hotel"):
    if start_node_swap is not None:
        base_seq[0] = start_node_swap

    # Hotel is drawn once
    # numpy.random.choice
    hotel = choice(instance_map["Hotel"], 1)[0]

    outseq = []
    for item in base_seq:
        if item == "Hotel" or item == "Sleep":
            outseq.append(hotel)
        else:
            # numpy.random.choice
            outseq.append(choice(instance_map[item], 1)[0])

    return outseq


def map_to_multival(seq, database):
    sem = []
    for item in seq:
        data = database[database["uri"] == item]
        tags = data["tags"].tolist()
        theme = data["theme"].tolist()
        archi = data["architecture"].tolist()
        sem_item = (set() if tags == [np.nan] else degeneralize(set(tags[0].split(';')), datatourisme_main),
                    set() if theme == [np.nan] else set(theme[0].split(';')),
                    set() if archi == [np.nan] else set(archi[0].split(';')))
        sem.append(sem_item)
    return sem


"""# Datatourism

## Load
"""

# Ontologies
raw_onto = nx.read_gml(ONTOLOGY_FILE)
datatourisme_main = raw_onto

# Instances
data_instances = pd.read_csv(INSTANCES_FILE)
hotels = data_instances[data_instances["category"] == "Hotel"]
restos = data_instances[data_instances["category"] == "Resto"]
activities = data_instances[data_instances["category"] == "act"]

instances = {
    "Resto": list(map(lambda x: x[2], restos.values)),
    "act_matin": list(map(lambda x: x[2], activities.values)),
    "act_aprem": list(map(lambda x: x[2], activities.values)),
    "Hotel": list(map(lambda x: x[2], hotels.values)),
    "act_nocturne": list(map(lambda x: x[2], activities.values))}

"""## Display"""

# display(datatourisme_theme, "datatourisme_theme.html", width="70%", height="600px")
# display(datatourisme_hist, "datatourisme_hist.html", width='80%')
# display(datatourisme_main, "datatourisme_main.html", width='80%')

"""# Demo"""

seqs = []
for i in range(10):
    base = build_basic_sequence(chain, "Start", "Sleep")
    ids = build_instance_sequence(base, instances)
    mv = map_to_multival(ids, data_instances)
    seqs.append(mv)

print(seqs[0][0])
print(seqs[1][0])
print("Similarity", mval_sim(seqs[0][0], seqs[1][0], [datatourisme_main, datatourisme_theme, datatourisme_hist]))


# Sim for CED
def sim(x, y):
    return mval_sim(x, y, [datatourisme_main, datatourisme_theme, datatourisme_hist])


msize = int((len(seqs) * (len(seqs) - 1)) / 2)
ed = np.empty(msize, dtype=np.float32)

pos = 0
for i in range(1, len(seqs)):
    for j in range(1, i + 1):

        seqA = np.empty((len(seqs[i]),), dtype=object)
        seqB = np.empty((len(seqs[j]),), dtype=object)

        for k in range(len(seqs[i])):
            seqA[k] = seqs[i][k]

        for k in range(len(seqs[j])):
            seqB[k] = seqs[j][k]

        ed[pos] = ced(seqA, seqB, sim, gaussian)
        pos += 1

lk = linkage(ed, "ward")
dendo = dendrogram(lk)

plt.show()
